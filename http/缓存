当浏览器第一次向服务器请求资源时会去询问服务器这个资源该不该缓存，用什么方法缓存。假设服务器同意浏览器缓存，并告诉浏览器一个资源失效时间，这个时间存放在Expires中如：Mon,10 Dec 1990 02:25:22GMT。那么这个资源在这个时间之前都能使用。那么有一个问题是：客户端的时间是可以被修改的，而且客户端和服务器时间未必一致。
既然返回一个绝对时间不好用，那么服务器就返回一个相对时间好了，这个时间在Cache-Control:max-age=300单位是秒（s）。现在好了300秒内这个资源就不会过期。那么有一种可能是300秒后我再次去服务器拿这个资源发现资源并没有被改变过，服务器又再次返回了同样的资源给我，这样的话就浪费了一次带宽。其实可以返回一条信息给浏览器表明缓存资源可以继续使用。
现在回到浏览器第一次请求的时候，服务器响应头中多了一个ETag:W/"e-cbxLFQW5zapn79tQwb/g6Q"。这个ETag是服务器根据资源计算出的唯一标识，通常配合max-age使用。当时间过期以后浏览器会将标识放在请求头中的If-None-Match，服务器收到请求以后会拿请求中的标识与服务器根据资源计算的Etag进行比较，若一致则返回响应头其中包含状态码304。不一致就返回新的资源。但是在分布式系统中每个机器生成的ETag不一样。
既然ETag也不是那么的靠谱，那么服务器第一次返回时在响应头中又加了一个字段Last-Modified。当资源过期时浏览器发现资源有Last-Modified，然后发请求时便在请求头增加了一个字段If-Modified-Since表示发送的请求时间，服务器拿到这个时间与资源的最后修改时间比较，如果修改时间比较新那么返回新的资源，否则返回Http 304。

1.当Expires与Cache-Control:max-age同时存在时max-age的优先级高。
2.[Last-Modified，If-Modified-Since]和[ETag、If-None-Match]经常会放在一起使用

浏览器默认的缓存是放在内存内的，但我们知道，内存里的缓存会因为进程的结束或者说浏览器的关闭而被清除，
而存在硬盘里的缓存才能够被长期保留下去。很多时候，我们在network面板中各请求的size项里，会看到两种不同的状态：from memory cache 和 from disk cache，
前者指缓存来自内存，后者指缓存来自硬盘。而控制缓存存放位置的，不是别人，就是我们在服务器上设置的Etag字段。
在浏览器接收到服务器响应后，会检测响应头部（Header），如果有Etag字段，那么浏览器就会将本次缓存写入硬盘中。
之所以拉取缓存会出现200、304两种不同的状态码，取决于浏览器是否有向服务器发起验证请求。 
只有向服务器发起验证请求并确认缓存未被更新，才会返回304状态码。

在我们配置缓存时一定要切记，浏览器在处理用户请求时，如果命中强缓存，浏览器会直接拉取本地缓存，不会与服务器发生任何通信，
也就是说，如果我们在服务器端更新了文件，并不会被浏览器得知，就无法替换失效的缓存。
所以我们在构建阶段，需要为我们的静态资源添加md5 hash后缀，避免资源更新而引起的前后端文件无法同步的问题。


