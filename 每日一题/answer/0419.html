<body>
    结构：
    display:none: 会让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击，
    visibility: hidden:不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击
    opacity: 0: 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击

    继承：
    display: none和opacity: 0：是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。
    visibility: hidden：是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式。

    性能：
    displaynone : 修改元素会造成文档回流,读屏器不会读取display: none元素内容，性能消耗较大
    visibility:hidden: 修改元素只会造成本元素的重绘,性能消耗较少读屏器读取visibility: hidden元素内容
    opacity: 0 ： 修改元素会造成重绘，性能消耗较少
</body>
<script>
    let a = [1, 2, 3, 4, 5];

    function xunhuan1() {
        let b = Array.from(a);
        b.map(item => (item = item + 2));
    }

    function xunhuan2() {
        let b = Array.from(a);
        for (let i = 0; i < a.length; i++) {
            b[i] = b[i] + 2;
        }
    }
    let time1 = performance.now();
    xunhuan1();
    let time2 = performance.now();
    console.log(time2 - time1);
    let time3 = performance.now();
    xunhuan2();
    let time4 = performance.now();
    console.log(time4 - time3)
    /* 
      缺陷1 – 意外衡量不重要的事情
      缺陷 #2 – 只衡量一次
      缺陷 #3 – 太依赖平均值 
      缺陷 #4 – 以可预测的方式比较函数
    */
</script>