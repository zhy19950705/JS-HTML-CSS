
通常浏览器缓存策略分为两种：强缓存和协商缓存。
####强缓存
实现强缓存可以通过两种响应头实现：`Expires` 和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，`state code` 为 200
```
Expires: Wed, 22 Oct 2018 08:41:00 GMT
```
`Expires`是是 HTTP / 1.0 的产物，表示资源会在 `Wed, 22 Oct 2018 08:41:00 GMT` 后过期，需要再次请求。并且 `Expires` 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。
```
Cache-control:max-age=30
```
`Cache-control`出现于HTTP/1.1,优先级高于`Expires`。该属性表示资源会在 30 秒后过期，需要再次请求。
####协商缓存
如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。

协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。
######Last-Modified 和 If-Modified-Since
`Last-Modified` 表示本地文件最后修改日期，`If-Modified-Since` 会将 `Last-Modified` 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。

但是如果在本地打开缓存文件，就会造成 `Last-Modified` 被修改，所以在 HTTP / 1.1 出现了 `ETag` 。

######ETag 和 If-None-Match
`ETag` 类似于文件指纹，`If-None-Match` 会将当前 `ETag` 发送给服务器，询问该资源 `ETag` 是否变动，有变动的话就将新的资源发送回来。并且 `ETag` 优先级比 `Last-Modified` 高。
####选择合适的缓存策略
对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略
* 对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存
* 对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。
* 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。

当浏览器第一次向服务器请求资源时会去询问服务器这个资源该不该缓存，用什么方法缓存。假设服务器同意浏览器缓存，并告诉浏览器一个资源失效时间，这个时间存放在Expires中如：Mon,10 Dec 1990 02:25:22GMT。那么这个资源在这个时间之前都能使用。那么有一个问题是：客户端的时间是可以被修改的，而且客户端和服务器时间未必一致。
既然返回一个绝对时间不好用，那么服务器就返回一个相对时间好了，这个时间在Cache-Control:max-age=300单位是秒（s）。现在好了300秒内这个资源就不会过期。那么有一种可能是300秒后我再次去服务器拿这个资源发现资源并没有被改变过，服务器又再次返回了同样的资源给我，这样的话就浪费了一次带宽。其实可以返回一条信息给浏览器表明缓存资源可以继续使用。
现在回到浏览器第一次请求的时候，服务器响应头中多了一个ETag:W/"e-cbxLFQW5zapn79tQwb/g6Q"。这个ETag是服务器根据资源计算出的唯一标识，通常配合max-age使用。当时间过期以后浏览器会将标识放在请求头中的If-None-Match，服务器收到请求以后会拿请求中的标识与服务器根据资源计算的Etag进行比较，若一致则返回响应头其中包含状态码304。不一致就返回新的资源。但是在分布式系统中每个机器生成的ETag不一样。
既然ETag也不是那么的靠谱，那么服务器第一次返回时在响应头中又加了一个字段Last-Modified。当资源过期时浏览器发现资源有Last-Modified，然后发请求时便在请求头增加了一个字段If-Modified-Since表示发送的请求时间，服务器拿到这个时间与资源的最后修改时间比较，如果修改时间比较新那么返回新的资源，否则返回Http 304。


浏览器默认的缓存是放在内存内的，但我们知道，内存里的缓存会因为进程的结束或者说浏览器的关闭而被清除，
而存在硬盘里的缓存才能够被长期保留下去。很多时候，我们在network面板中各请求的size项里，会看到两种不同的状态：from memory cache 和 from disk cache，
前者指缓存来自内存，后者指缓存来自硬盘。而控制缓存存放位置的，不是别人，就是我们在服务器上设置的Etag字段。
在浏览器接收到服务器响应后，会检测响应头部（Header），如果有Etag字段，那么浏览器就会将本次缓存写入硬盘中。
之所以拉取缓存会出现200、304两种不同的状态码，取决于浏览器是否有向服务器发起验证请求。 
只有向服务器发起验证请求并确认缓存未被更新，才会返回304状态码。

在我们配置缓存时一定要切记，浏览器在处理用户请求时，如果命中强缓存，浏览器会直接拉取本地缓存，不会与服务器发生任何通信，
也就是说，如果我们在服务器端更新了文件，并不会被浏览器得知，就无法替换失效的缓存。
所以我们在构建阶段，需要为我们的静态资源添加md5 hash后缀，避免资源更新而引起的前后端文件无法同步的问题。
